GitHub Actions runs the trading worker on a schedule (serverless, free).

Render (free) hosts the UI (sleep okay).

GitHub Pages hosts interactive charts (free) and serves the chart assets fetched from the repo.

The worker defaults to DRY_RUN=True so you can test without placing live orders.

Copy/paste everything, follow the steps, and you’ll be live.

Project layout (final)
my-kraken-bot/
├── worker.py
├── requirements.txt
├── .github/
│   └── workflows/
│       └── worker.yml
├── ui/
│   ├── index.html
│   ├── charts.html
│   └── style.css
├── data/
│   └── history.json
└── .gitignore

1) worker.py (final — safe default DRY_RUN)

Save as worker.py.

"""
worker.py
Serverless trading worker designed to run once and exit.
- Uses OpenAI to pick top-10 Kraken symbols for swing trading
- Records simple history (timestamp, top10, equity placeholder) to data/history.json
- Optionally (DRY_RUN=False) will place simulated or real Kraken orders (simple market buys/sells)
- Intended to run in GitHub Actions on a schedule
"""

import os
import json
import time
from datetime import datetime
import openai

# Optional Kraken libs used only if DRY_RUN=False and KRAKEN credentials provided
try:
    from krakenex import API as KrakenAPIConnector
    from pykrakenapi import KrakenAPI
except Exception:
    KrakenAPIConnector = None
    KrakenAPI = None

# ---------- CONFIG ----------
DRY_RUN = True   # KEEP True initially. Set to False only after careful local testing.
TOP_N = 10
HISTORY_FILE = "data/history.json"
OPENAI_MODEL = "gpt-4o"  # change if you prefer another model
# --------------------------------

openai.api_key = os.getenv("OPENAI_API_KEY")

KRAKEN_KEY = os.getenv("KRAKEN_API_KEY")
KRAKEN_SECRET = os.getenv("KRAKEN_API_SECRET")

def ensure_history_file():
    os.makedirs("data", exist_ok=True)
    if not os.path.exists(HISTORY_FILE):
        with open(HISTORY_FILE, "w") as f:
            json.dump([], f, indent=2)

def read_history():
    ensure_history_file()
    with open(HISTORY_FILE, "r") as f:
        return json.load(f)

def write_history(data):
    ensure_history_file()
    with open(HISTORY_FILE, "w") as f:
        json.dump(data, f, indent=2)

def ask_openai_for_top_symbols():
    prompt = (
        f"You are an expert crypto swing trader. Return ONLY a JSON array of the top {TOP_N} "
        "spot trading pairs on Kraken for swing trading over the next 1-3 weeks. "
        "Use Kraken pair format (example: \"XBT/USD\", \"ETH/USD\"). Output ONLY a JSON array."
    )
    try:
        resp = openai.ChatCompletion.create(
            model=OPENAI_MODEL,
            messages=[{"role":"user","content":prompt}],
            temperature=0.6,
            max_tokens=300
        )
        text = resp["choices"][0]["message"]["content"].strip()
        # parse JSON array or fallback: split by commas
        try:
            arr = json.loads(text)
            if isinstance(arr, list):
                return [str(x).strip() for x in arr][:TOP_N]
        except Exception:
            # allow comma-separated fallback
            parts = [p.strip().strip('"').strip("'") for p in text.replace("\n",",").split(",") if p.strip()]
            return parts[:TOP_N]
    except Exception as e:
        print("OpenAI error:", e)
    return []

def ask_openai_bullish(symbol):
    prompt = (
        f"Is {symbol} bullish for a 1-3 week swing trade horizon? Consider sentiment, recent news, and technicals. "
        "Return a JSON object EXACTLY like: {\"bullish\": true/false, \"reason\": \"one-sentence reason\"}"
    )
    try:
        resp = openai.ChatCompletion.create(
            model=OPENAI_MODEL,
            messages=[{"role":"user","content":prompt}],
            temperature=0.3,
            max_tokens=150
        )
        text = resp["choices"][0]["message"]["content"].strip()
        try:
            return json.loads(text)
        except Exception:
            # crude fallback
            lower = text.lower()
            bullish = "yes" in lower or "true" in lower or "bullish" in lower
            return {"bullish": bullish, "reason": text}
    except Exception as e:
        print("OpenAI bullish check error:", e)
        return {"bullish": False, "reason": "openai_error"}

def get_equity_placeholder():
    # Robust equity calculation would query Kraken balances. For safety & simplicity we return None if not available.
    if DRY_RUN or KrakenAPIConnector is None:
        return None
    try:
        conn = KrakenAPIConnector(KRAKEN_KEY, KRAKEN_SECRET)
        k = KrakenAPI(conn)
        bal = k.get_account_balance()
        # sum all balances in account — this is naive because conversion to USD isn't handled
        total = 0.0
        for v in bal["balance"].values():
            try:
                total += float(v)
            except:
                pass
        return total
    except Exception as e:
        print("Error fetching equity:", e)
        return None

# Optional simplified order functions (very naive; real trading requires careful step-size handling)
def place_market_buy(pair, notional):
    if DRY_RUN:
        print(f"[DRY_RUN] would BUY {pair} for ${notional}")
        return {"status":"simulated","pair":pair,"notional":notional}
    if KrakenAPIConnector is None:
        raise RuntimeError("Kraken libs not installed")
    # NOTE: implement carefully if enabling live trading
    api = KrakenAPIConnector(KRAKEN_KEY, KRAKEN_SECRET)
    k = KrakenAPI(api)
    # This is placeholder — user must implement precise sizing & pair handling
    return {"status":"not-implemented"}

def place_market_sell(pair, volume):
    if DRY_RUN:
        print(f"[DRY_RUN] would SELL {pair} volume {volume}")
        return {"status":"simulated","pair":pair,"volume":volume}
    return {"status":"not-implemented"}

def main():
    ensure_history_file()
    ts = datetime.utcnow().isoformat()
    print("=== worker run at", ts, "===\nDRY_RUN =", DRY_RUN)

    top = ask_openai_for_top_symbols()
    print("Top list from OpenAI:", top)

    # For each current position (we don't maintain a DB here in the serverless run),
    # we conservativey just record the top list and a bullish check for each symbol.
    results = []
    for s in top:
        bull = ask_openai_bullish(s)
        results.append({"symbol": s, "bullish": bull.get("bullish", False), "reason": bull.get("reason","")})

    equity = get_equity_placeholder()

    # Append to history
    hist = read_history()
    hist.append({
        "time": ts,
        "top": top,
        "top_diagnostics": results,
        "equity": equity
    })
    # Keep history size reasonable (e.g., last 10k entries)
    if len(hist) > 20000:
        hist = hist[-20000:]
    write_history(hist)

    print("History length:", len(hist))
    print("Worker finished.")

if __name__ == "__main__":
    main()


Notes on worker.py:

DRY_RUN=True by default. Test everything while DRY_RUN is True. Only set to False after you audit and add real order logic (and agree on sizing, pair formatting, and precision).

The script records history to data/history.json and does not attempt aggressive trading in its default form.

2) requirements.txt

Save as requirements.txt:

openai
krakenex
pykrakenapi


(If you only plan to keep DRY_RUN=True forever you can omit kraken libs; but keep them here to allow future live mode.)

3) GitHub Action workflow — .github/workflows/worker.yml

Save as .github/workflows/worker.yml:

name: scheduled-trading-worker

on:
  schedule:
    - cron: "*/15 * * * *"   # every 15 minutes (change if you want)
  workflow_dispatch: {}      # manual run button in Actions

jobs:
  run_worker:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          persist-credentials: true

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Install deps
        run: pip install -r requirements.txt

      - name: Run worker
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          KRAKEN_API_KEY: ${{ secrets.KRAKEN_API_KEY }}
          KRAKEN_API_SECRET: ${{ secrets.KRAKEN_API_SECRET }}
        run: |
          python worker.py
          # make sure history file exists and is tracked
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add data/history.json || true
          git commit -m "update history" || true
          git push || true


Notes:

The repo will be checked out and data/history.json will be committed back to the repo by the Action using the workflow’s default token — this keeps the GitHub-hosted history up to date.

You can adjust the cron schedule. Every 15 minutes is common; every 5 minutes will use more Actions minutes but is usually still fine with free tier limits.

4) UI files (ui/)

Create directory ui/ and add the following files.

ui/index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Kraken Swing Bot — Dashboard</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="wrap">
    <h1>Kraken Swing Bot</h1>
    <p>Dashboard (updated from GitHub Actions history)</p>
    <p><a href="charts.html" target="_blank">Open Charts</a> — (GitHub Pages / Render)</p>

    <h2>Latest Top-10 (OpenAI)</h2>
    <pre id="top">loading...</pre>

    <h2>Latest run timestamp</h2>
    <div id="ts">loading...</div>

    <script>
      async function loadLatest() {
        const url = "https://raw.githubusercontent.com/YOUR_GITHUB_USERNAME/my-kraken-bot/main/data/history.json";
        try {
          const res = await fetch(url);
          const hist = await res.json();
          if(!hist || hist.length===0) {
            document.getElementById("top").innerText = "no history yet";
            document.getElementById("ts").innerText = "-";
            return;
          }
          const last = hist[hist.length-1];
          document.getElementById("top").innerText = JSON.stringify(last.top, null, 2);
          document.getElementById("ts").innerText = last.time;
        } catch (e) {
          document.getElementById("top").innerText = "error loading history";
          document.getElementById("ts").innerText = e;
        }
      }
      loadLatest();
    </script>
  </div>
</body>
</html>


Important: Replace YOUR_GITHUB_USERNAME and my-kraken-bot with your real GitHub username and repo name in the url variable.

ui/charts.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Kraken Swing Bot — Charts</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="wrap">
    <h1>Equity & Top-Symbol History</h1>
    <p>Data pulled from <code>data/history.json</code> in your GitHub repo.</p>

    <canvas id="equityChart" height="120"></canvas>
    <h3>Top-10 Symbol Snapshot (text by run)</h3>
    <div id="symbols"></div>

    <script>
      async function loadData() {
        const url = "https://raw.githubusercontent.com/YOUR_GITHUB_USERNAME/my-kraken-bot/main/data/history.json";
        const res = await fetch(url);
        const hist = await res.json();
        if(!hist || hist.length===0) {
          document.getElementById("symbols").innerText = "No history yet";
          return;
        }
        // equity timeseries
        const times = hist.map(h => h.time);
        const equities = hist.map(h => (h.equity === null ? null : h.equity));

        // create equity dataset — filter nulls
        const labels = times;
        const data = equities.map(v => v === null ? null : v);

        new Chart(document.getElementById("equityChart").getContext("2d"), {
          type: "line",
          data: {
            labels: labels,
            datasets: [{
              label: "Equity (raw / placeholder)",
              data: data,
              fill: false,
              spanGaps: true
            }]
          },
          options: {
            scales: { x: { display: true }, y: { display: true } }
          }
        });

        // Show latest symbol snapshots
        const out = document.getElementById("symbols");
        out.innerHTML = "";
        const latest = hist.slice(-10).reverse(); // show last 10 runs
        latest.forEach(h => {
          const div = document.createElement("div");
          div.className = "snap";
          const t = document.createElement("div");
          t.className = "snap-time";
          t.innerText = h.time;
          const list = document.createElement("pre");
          list.innerText = JSON.stringify(h.top, null, 2);
          div.appendChild(t);
          div.appendChild(list);
          out.appendChild(div);
        });
      }
      loadData();
    </script>
  </div>
</body>
</html>


Again, replace the GitHub raw URL placeholders with your repo path.

ui/style.css
body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background:#0b0b0b; color:#eaeaea; padding:40px; }
.wrap { max-width: 900px; margin: auto; }
a { color:#4fe27a; text-decoration:none; }
pre { background:#111; padding:12px; border-radius:6px; overflow:auto; }
.snap { border:1px solid #222; margin-bottom:10px; padding:8px; border-radius:6px; background:#071117 }
.snap-time { font-size:0.85rem; color:#99d1ff; margin-bottom:6px; }
canvas { background:#fff; border-radius:8px; padding:8px; }

5) data/history.json initial file

Create data/history.json with this initial content:

[]


This guarantees the file exists for the action to edit.

6) .gitignore

Save as .gitignore:

venv/
__pycache__/
*.pyc
data/history.json
.env


Note: If you want data/history.json tracked by git so Actions can update it, remove it from .gitignore. In our workflow we commit data/history.json, so remove it from .gitignore or ensure it is not ignored. For simplicity, remove the data/history.json line from .gitignore (or keep it but create an initial commit that adds the file).

7) Create the GitHub repo & push

Create a new repository on GitHub named my-kraken-bot (or your preferred name).

Locally:

git init
git branch -m main
git remote add origin https://github.com/YOUR_GITHUB_USERNAME/my-kraken-bot.git
git add .
git commit -m "Initial commit — swing bot + UI + workflow"
git push -u origin main


(If you use SSH, use the SSH URL instead.)

8) Add Secrets in GitHub

Go to your repo → Settings → Secrets and variables → Actions → New repository secret. Add:

OPENAI_API_KEY = your OpenAI key (required)

KRAKEN_API_KEY = your Kraken API key (optional if DRY_RUN=True)

KRAKEN_API_SECRET = your Kraken secret (optional if DRY_RUN=True)

9) Test & run the worker locally (recommended first)

Locally test (before enabling live trading):

python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
export OPENAI_API_KEY="sk-..."
python worker.py


You should see the script append an entry to data/history.json. If OpenAI errors, check the key.

GitHub Actions will run the same script periodically once workflow is active.

10) Enable GitHub Actions & run manually

In the repo, go to Actions → you should see scheduled-trading-worker.

Click Run workflow (workflow_dispatch) to test immediately.

Check the Actions logs. On success it will update data/history.json with new entries (and the Action will attempt to commit/push).

11) Host UI: Render (free) (optional but recommended)

Render is optional — GitHub Pages will host the ui/ folder too. If you prefer Render:

Create new Static Site on Render.

Connect to your GitHub repo and point Root to /ui.

Build & Publish: Render will serve index.html and charts.html.

Free tier OK (it sleeps). UI will wake when visited.

12) Host UI: GitHub Pages (free) — recommended for charts

In repo → Settings → Pages.

Source: Branch main, folder /ui.

Save. GitHub will provide a URL:
https://YOUR_GITHUB_USERNAME.github.io/my-kraken-bot/

Visit charts.html there: https://.../charts.html

GitHub Pages serves the static site free and reliably. The chart pages will fetch data/history.json from the repo raw URL.

13) Final checklist & safety

 Confirm OPENAI_API_KEY secret set in GitHub.

 Keep DRY_RUN = True in worker.py until you fully test everything.

 If you enable trading (set DRY_RUN=False) implement proper pair formatting, step-size & precision handling, error handling for partial fills, order throttling, and safety stops.

 Start with very small volume or small per-trade notional.

 Keep API keys secure. Revoke keys immediately if compromised.

14) Useful tweaks (pick any)

To run less frequently change cron in worker.yml (e.g., hourly: 0 * * * *).

To preserve history without git push you can upload data/history.json to a separate storage (S3) — but GitHub commit approach keeps everything in one place.

Add Telegram/Email alerts: I can provide an action step to call a webhook.

Add a DB (sqlite) & live position tracking: I can convert the worker to maintain positions.json with simulated fills.

15) Next steps I can do for you (I’ll include these if you ask)

Convert the worker from DRY_RUN to real trading, properly handling Kraken pair mapping, lot sizes, orderbook checks, and position sizing.

Add Telegram/Discord alerts for open/close actions.

Add stop-loss / take-profit rules and backtesting harness.

Add authentication to the Render UI (so it's not public).

Create a Dockerfile and Docker-based Render deployment.

If you want, I’ll generate all the files in a single downloadable ZIP (ready to push) or produce the exact small changes to make the worker place real orders (I’ll be explicit about precision, lot size lookups, and safety checks). Which of those would you like next?